<!doctype html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <title>Myron Marston &raquo; Custom Request Matchers in VCR 2.0</title>
    <link href="/n/stylesheets/screen.css?1314684504" rel="stylesheet" type="text/css" />
    <link rel="alternate" type="application/atom+xml" href="/n/atom.xml" />
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.2/jquery.min.js"></script>
  </head>
  <body>
    <div id='menu'>
  <div class="dev-blog active">
    <a href='/n/dev-blog'>Dev Blog</a>
  </div>
  <div class="china">
    <a href='/n/china'>China</a>
  </div>
  <div class="music">
    <a href='/n/music'>Music</a>
  </div>
  <div class="open-source">
    <a href='/n/open-source'>Open Source</a>
  </div>
</div>

    <div id='contents' class='medium-wide dev-blog'>
      <div id="post" class='section'>
  <h1>Custom Request Matchers in VCR 2.0</h1>
  <p class="post-date">âžœ 10 Oct 2011</p>

  <div class="content">
    <p>Over the last six weeks, I&#8217;ve been working extensively on VCR 2.0. I&#8217;ve completely rewritten most of the internals and have finally been able to add a feature people have wanted in VCR for over a year: custom request matchers.</p>

<p>I just released VCR 2.0 beta 1 a few days ago, so I figured it&#8217;s time to blog a bit about what the feature is, why it&#8217;s useful, and why it took me so long to add it to VCR.</p>

<h2 id='the_problem'>The problem</h2>

<p>VCR, at its core, is a very simple idea: you run your tests for the first time, and VCR records the HTTP requests and responses. Later, when you run them again, it will use the recorded responses rather than allowing real ones, which has many benefits (speed, test determinism and test accuracy being the main ones).</p>

<p>It&#8217;s important for VCR to replay the <em>right</em> response, and it can&#8217;t simply rely on the order of the recorded HTTP interactions. You might be using a single cassette for multiple tests, and those tests may not always run in the same order. Or you may change your implementation code so that it makes the HTTP requests in a different order. VCR needs a way to match a recorded HTTP interaction to a new one.</p>

<p>Since VCR 1.1.0 (now over a year ago), VCR has allowed users to customize how it matches a previously recorded HTTP interaction to a new request, by using the <a href='https://www.relishapp.com/myronmarston/vcr/v/1-11-3/docs/cassettes/request-matching'><code>:match_requests_on</code> cassette option</a>. By default, it matches on <code>:uri</code> and <code>:method</code>, which works great for most REST-ish APIs.</p>

<p>This gave VCR some nice flexibility, but it never really worked well for the most common case where the <code>:uri</code>/<code>:method</code> matching didn&#8217;t work: APIs that have non-deterministic URIs. Each time your tests run, the URI is different, and VCR would not match the new request the old one, causing it to either re-record the HTTP interaction, or raise a &#8220;real connections are not allowed&#8221; error, depending on your configuration.</p>

<p>The common example is an API that requires clients to sign requests by putting a token (typically generated by hashing several things, including a timestamp) as a query parameter in the URI. Amazon&#8217;s APIs do this all over the place. It&#8217;s a really bad idea to design your APIs this way <sup id='fnref:1'><a href='#fn:1' rel='footnote'>1</a></sup>, but it&#8217;s a reality of the web and VCR needs to work well for users who are using these APIs.</p>

<h2 id='how_vcr_1x_worked'>How VCR 1.x worked</h2>

<p>I&#8217;ve wanted to make VCR work well for these sorts of APIs for a long time, but the way VCR 1.x worked prevented a good solution. In VCR 1.x, it uses declaritive APIs provided by FakeWeb, WebMock and Typhoeus. When you insert a cassette, VCR makes calls to these libraries that are a bit like this:</p>
<script src='https://gist.github.com/1272818.js?file=vcr_stubs.rb'> </script><noscript>
  <pre class='gist-no-script'><code># vcr_stubs.rb

FakeWeb.register_uri(request.method, request.uri, response.to_fakeweb_hash)

WebMock.stub_request(
  request.method, request.uri
).to_return(response.to_webmock_hash)

Typhoeus::Hydra.stub(
  request.method, request.uri
).and_return(response.to_typhoeus_response)</code></pre>
</noscript>
<p>These libraries all allow you to register a stub using a regex rather than a full URI, and this is in fact what VCR 1.x did to support <code>:match_requests_on =&gt; [:host, :path]</code>. This works OK, but doesn&#8217;t provide an easy way to solve the problem of URIs with non-deterministic query parameters. Building a regex that correctly matches all of a URI except a particular query parameter is not easy, and it would have been even more difficult to put code that does this generically in VCR so that users could easily match on a URI while ignoring particular query parameters.</p>

<h2 id='the_big_rewrite'>The big rewrite</h2>

<p>I realized about a year ago that if I was going to solve this problem in VCR, I needed to change the way VCR interacts with FakeWeb, WebMock, and Typhoeus: rather than using their declaritive stub registration APIs, VCR should use these libraries to hook into the HTTP request so that an appropriate response can be chosen <em>at request time</em>.</p>

<p>To get this to work I had to rewrite a large portion of VCR&#8217;s internals. After about <a href='https://github.com/myronmarston/vcr/compare/e36ed0e812b3a1650090d011d1bf972ae503ad79...221647b75d5aaa105472bd5c2f1d97a8c6b58a9a'>70 commits</a>, the refactoring, and the new features it enabled, was complete. It was, if nothing else, an intersting exercise in how to safely do a large refactoring. I kept the test suite passing all along the way. I don&#8217;t think I can emphasize enough how important a good test suite was to making this possible.</p>

<p>The great thing about this rewrite is that it de-couples VCR from the declarative APIs of the libraries it integrates with. When I want to add a new feature to VCR, I no longer have to try to get a supporting API added to FakeWeb, WebMock and Typhoeus&#8211;I can just add it to VCR itself.</p>

<h2 id='request_matching_in_vcr_20'>Request matching in VCR 2.0</h2>

<p>In VCR 2.0, a request matcher is simply an object that responds to <code>#call</code> with two arguments and returns <code>true</code> if the given requests should be considered identical, or <code>false</code> if they should not be considered identical.</p>

<p>The simplest request matcher is probably a lambda:</p>
<script src='https://gist.github.com/1272818.js?file=lambda_matcher.rb'> </script><noscript>
  <pre class='gist-no-script'><code># lambda_matcher.rb

port_matcher = lambda do |request_1, request_2|
  URI(request_1.uri).port == URI(request_2.uri).port
end

VCR.use_cassette('example', :match_requests_on =&gt; [:method, port_matcher]) do
  # make an HTTP request
end</code></pre>
</noscript>
<p>You can also register it as a named matcher and use the name in your <code>:match_requests_on</code> option:</p>
<script src='https://gist.github.com/1272818.js?file=register_matcher.rb'> </script><noscript>
  <pre class='gist-no-script'><code># register_matcher.rb

VCR.configure do |c|
  c.register_request_matcher :port do |request_1, request_2|
    URI(request_1.uri).port == URI(request_2.uri).port
  end
end

VCR.use_cassette('example', :match_requests_on =&gt; [:method, :port]) do
  # make an HTTP request
end</code></pre>
</noscript>
<p>In fact, this is exactly how the <a href='https://github.com/myronmarston/vcr/blob/v2.0.0.beta1/lib/vcr/request_matcher_registry.rb#L64-71'>built-in request matchers</a> (<code>:method</code>, <code>:uri</code>, <code>:host</code>, <code>:path</code>, <code>:headers</code> and <code>:body</code>) work now.</p>

<p>Finally, for the specific case of URIs with non-deterministic query parameters, VCR provides a simple way to create a request matcher:</p>
<script src='https://gist.github.com/1272818.js?file=uri_without_timestamp.rb'> </script><noscript>
  <pre class='gist-no-script'><code># uri_without_timestamp.rb

VCR.use_cassette('example', :match_requests_on =&gt; [:method, VCR.request_matchers.uri_without_param(:timestamp)]) do
  # make an HTTP request with a URI that has a non-determinstic
  # timestamp query parameter
end
</code></pre>
</noscript>
<p>This is only the tip of the iceberg. You can match requests on specific portions of the request body or headers. I can imagine people using this to wrap up the specific set of matchers used for requests to a particular API into a single matcher that simply delegates to the desired matchers&#8211;that way, you can write <code>:match_requests_on =&gt; [:amazon]</code> rather than <code>:match_requests_on =&gt; [:method, :uri_without_signing, :body]</code> (or whatever).</p>

<p>Check out the <a href='https://www.relishapp.com/myronmarston/vcr/v/2-0-0-beta1/docs/request-matching'>relish docs</a> for fuller examples.</p>

<p>If you&#8217;ve had problems with how VCR does request matching in the past, or if you think this sounds useful, please give this beta a try. There are a number of other changes, too&#8211;check out the <a href='https://www.relishapp.com/myronmarston/vcr/v/2-0-0-beta1/docs/changelog'>changelog</a> for the full story.</p>
<div class='footnotes'><hr /><ol><li id='fn:1'>
<p>Consider that URI stands for <a href='http://en.wikipedia.org/wiki/Uniform_Resource_Identifier'>Uniform Resource Identifier</a>. Authentication and request signing have nothing to do with identifiying the requested resource. These are orthogonal concerns that should be expressed orthogonally in the HTTP request headers.</p>
<a href='#fnref:1' rev='footnote'>&#8617;</a></li></ol></div>
  </div>
</div>

<div id="disqus_thread" class='section'></div>
<script type="text/javascript">
    var disqus_shortname  = 'myronmarston-personal-site';
    var disqus_identifier = '/n/dev-blog/2011/10/custom-request-matchers-in-vcr-2-0';
    var disqus_title      = 'Custom Request Matchers in VCR 2.0';
    var disqus_url        = 'http://myronmars.to/n/dev-blog/2011/10/custom-request-matchers-in-vcr-2-0';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<div class='section'>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
</div>


    </div>
    <div id='about'>
  <div class='links'>
    <h2>Follow Me</h2>
    <ul>
      <li><a href="http://twitter.com/myronmarston">Twitter</a></li>
      <li><a href="https://github.com/myronmarston">Github</a></li>
      <li><a href="/n/atom.xml">Atom Feed</a></li>
      <li><a href="/n/resume">Resume</a></li>
    </ul>
  </div>
  <div class='bio'>
    <h2>About Me</h2>
    <p>
      <a href="http://bluebirdsandthings.wordpress.com/">Husband and father</a>,
      musician, software engineer at <a href="http://www.seomoz.org/">SEOmoz</a>,
      open source developer specializing in Ruby and Rails, world traveler and Christian.
    </p>
  </div>
</div>

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-3938147-3']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
<script type="text/javascript" src="/n/javascript/audio.js"></script>

  </body>
</html>

